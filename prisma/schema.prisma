generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DIRECT_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                   String                   @id @default(cuid())
  walletAddress        String?                  @unique
  role                 UserRole                 @default(USER)
  createdAt            DateTime                 @default(now())
  email                String?                  @unique
  passHash             String?
  solWallet            String?                  @unique
  solWalletLinkedAt    DateTime?
  welcomeEmailSentAt   DateTime?
  supabaseId           String?                  @unique
  mvmPoints            Int                      @default(0)
  referralCode         String?                  @unique
  referredAt           DateTime?
  referredById         String?
  allTimeStat          AllTimeUserStat?
  commentsAuthored     Comment[]                @relation("CommentAuthor")
  commentsRemoved      Comment[]                @relation("CommentRemovedBy")
  memberVotes          CommentMemberVote[]
  modVotes             CommentModVote[]
  sourceGradesEarned   CommentSourceGrade[]     @relation("CommentSourceGradeAuthor")
  sourceGradesMade     CommentSourceGrade[]     @relation("CommentSourceGradeMod")
  integrityFlagsAuthor ModeratorIntegrityFlag[] @relation("FlaggedAuthor")
  integrityFlagsMod    ModeratorIntegrityFlag[] @relation("FlaggedMod")
  monthlyStats         MonthlyUserStat[]
  passwordResetTokens  PasswordResetToken[]
  rewardClaims         RewardClaim[]
  rewardEpochLeaves    RewardEpochLeaf[]
  rewardEvents         RewardEvent[]
  claimLeaves          ClaimLeaf[]
  manualPayments       ManualPayment[]
  sessions             Session[]
  subscription         Subscription?
  referredBy           User?                    @relation("UserReferrals", fields: [referredById], references: [id])
  referrals            User[]                   @relation("UserReferrals")
  scoreAdjustments     VideoScoreAdjustment[]
  starRatings          VideoStarRating[]
  walletLinkChallenges WalletLinkChallenge[]
  weeklyStats          WeeklyUserStat[]
  weeklyVoterStats     WeeklyVoterStat[]

  @@index([referredById])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model WalletLinkChallenge {
  id        String    @id @default(cuid())
  userId    String
  nonce     String    @unique
  message   String
  createdAt DateTime  @default(now())
  expiresAt DateTime
  usedAt    DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PasswordResetToken {
  id            String    @id @default(cuid())
  userId        String
  tokenHash     String    @unique
  expiresAt     DateTime
  usedAt        DateTime?
  createdAt     DateTime  @default(now())
  resendEmailId String?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([resendEmailId])
}

model PasswordResetAttempt {
  id        String   @id @default(cuid())
  email     String
  ip        String
  userAgent String?
  action    String
  allowed   Boolean
  reason    String?
  createdAt DateTime @default(now())

  @@index([email, createdAt])
  @@index([ip, createdAt])
  @@index([action, createdAt])
}

model ResendWebhookEvent {
  id            String   @id @default(cuid())
  svixId        String   @unique
  svixTimestamp String?
  svixSignature String?
  type          String
  createdAt     DateTime @default(now())
  resendEmailId String?
  to            String?
  from          String?
  subject       String?
  payload       Json

  @@index([type, createdAt])
  @@index([resendEmailId])
  @@index([to])
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  tier                 SubscriptionTier
  status               SubscriptionStatus @default(PENDING)
  expiresAt            DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  nowPaymentsPaymentId String?
  nowPaymentsInvoiceId String?
  lastTxSig            String?
  nowPaymentsOrderId   String?            @unique
  cancelAtPeriodEnd    Boolean            @default(false)
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([expiresAt])
}

model Video {
  id           String                 @id @default(cuid())
  slug         String                 @unique
  title        String
  embedUrl     String
  tags         String[]               @default([])
  createdAt    DateTime               @default(now())
  isShowcase   Boolean                @default(false)
  adminScore   Int                    @default(75)
  viewsCount   Int                    @default(0)
  avgStars     Float                  @default(0)
  starsCount   Int                    @default(0)
  thumbnailUrl String?
  sourceViews  Int                    @default(0)
  rank         Int?                   @unique
  comments     Comment[]
  sourceGrades CommentSourceGrade[]
  adjustments  VideoScoreAdjustment[]
  starRatings  VideoStarRating[]

  @@index([isShowcase])
  @@index([rank])
}

model VideoStarRating {
  id        String   @id @default(cuid())
  videoId   String
  userId    String
  stars     Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([videoId, userId])
  @@index([userId])
}

model Comment {
  id               String                 @id @default(cuid())
  videoId          String
  authorId         String
  body             String
  createdAt        DateTime               @default(now())
  status           CommentStatus          @default(ACTIVE)
  removedById      String?
  removedAt        DateTime?
  removedReason    String?
  memberDislikes   Int                    @default(0)
  memberLikes      Int                    @default(0)
  score            Int                    @default(0)
  author           User                   @relation("CommentAuthor", fields: [authorId], references: [id])
  removedBy        User?                  @relation("CommentRemovedBy", fields: [removedById], references: [id])
  video            Video                  @relation(fields: [videoId], references: [id], onDelete: Cascade)
  memberVotes      CommentMemberVote[]
  modVotes         CommentModVote[]
  sourceGrades     CommentSourceGrade[]
  scoreAdjustments VideoScoreAdjustment[]

  @@index([videoId])
  @@index([authorId])
  @@index([status])
}

model CommentMemberVote {
  id            String   @id @default(cuid())
  commentId     String
  voterId       String
  value         Int
  flipCount     Int      @default(0)
  lastChangedAt DateTime @default(now())
  createdAt     DateTime @default(now())
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  voter         User     @relation(fields: [voterId], references: [id], onDelete: Cascade)

  @@unique([commentId, voterId])
  @@index([voterId])
}

model CommentModVote {
  id            String   @id @default(cuid())
  commentId     String
  modId         String
  value         Int
  flipCount     Int      @default(0)
  lastChangedAt DateTime @default(now())
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod           User     @relation(fields: [modId], references: [id], onDelete: Cascade)

  @@unique([commentId, modId])
  @@index([modId])
}

model VideoScoreAdjustment {
  id        String   @id @default(cuid())
  videoId   String
  commentId String
  modId     String
  direction Int
  createdAt DateTime @default(now())
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod       User     @relation(fields: [modId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@index([videoId])
  @@index([commentId])
  @@index([modId])
}

model ModeratorIntegrityFlag {
  id         String    @id @default(cuid())
  modId      String
  authorId   String
  reason     String
  createdAt  DateTime  @default(now())
  resolvedAt DateTime?
  author     User      @relation("FlaggedAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  mod        User      @relation("FlaggedMod", fields: [modId], references: [id], onDelete: Cascade)

  @@index([modId])
  @@index([authorId])
}

model RateLimit {
  id          String @id @default(cuid())
  scope       String
  key         String
  windowStart Int
  count       Int    @default(0)

  @@unique([scope, key, windowStart])
  @@index([scope, key, windowStart])
}

model VoteEvent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  userId    String?
  commentId String
  ip        String
  userAgent String?
  action    String
  vote      Int?
  prevVote  Int?

  @@index([ip, createdAt])
  @@index([userId, createdAt])
}

model CommentSourceGrade {
  id        String   @id @default(cuid())
  commentId String
  videoId   String
  modId     String
  authorId  String
  direction Int
  createdAt DateTime @default(now())
  author    User     @relation("CommentSourceGradeAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod       User     @relation("CommentSourceGradeMod", fields: [modId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([commentId, modId])
  @@index([authorId, createdAt])
  @@index([videoId, createdAt])
  @@index([modId, createdAt])
}

model SiteStat {
  key       String   @id
  value     BigInt   @default(0)
  updatedAt DateTime @updatedAt
}

model RewardEvent {
  id          String       @id @default(cuid())
  userId      String
  type        RewardType
  amount      BigInt
  status      RewardStatus @default(PENDING)
  weekKey     String
  refType     String
  refId       String
  txSig       String?
  createdAt   DateTime     @default(now())
  paidAt      DateTime?
  claimedAt   DateTime?
  merkleIndex Int?
  merkleProof String?
  user        User         @relation(fields: [userId], references: [id])

  @@unique([refType, refId])
  @@index([weekKey, status])
  @@index([userId, status])
  @@index([type, status])
}

model WeeklyUserStat {
  id              String   @id @default(cuid())
  weekKey         String
  userId          String
  diamondComments Int      @default(0)
  mvmPoints       Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  scoreReceived   Int      @default(0)
  user            User     @relation(fields: [userId], references: [id])

  @@unique([weekKey, userId])
  @@index([weekKey])
}

model AdminConfig {
  id                       String   @id @default(cuid())
  minWeeklyScoreThreshold  Int      @default(10)
  minMvmThreshold          Int      @default(1)
  allTimeLikesBpsOfLikes   Int      @default(1000)
  memberVoterBpsOfLikes    Int      @default(500)
  voterRewardPerVoteAtomic BigInt   @default(0)
  updatedAt                DateTime @updatedAt
  createdAt                DateTime @default(now())
}

model AdminActionRun {
  id        String         @id @default(cuid())
  key       AdminActionKey @unique
  lastRunAt DateTime?
  lastOk    Boolean        @default(false)
  lastMsg   String?
  updatedAt DateTime       @updatedAt
}

model AllTimeUserStat {
  userId        String   @id
  scoreReceived Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])
}

model MonthlyUserStat {
  id        String   @id @default(cuid())
  monthKey  String
  userId    String
  mvmPoints Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@unique([monthKey, userId])
  @@index([monthKey])
}

model WeeklyVoterStat {
  id        String   @id @default(cuid())
  weekKey   String
  userId    String
  votesCast Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@unique([weekKey, userId])
  @@index([weekKey])
}

model RewardBatch {
  id          String   @id @default(cuid())
  weekKey     String   @unique
  merkleRoot  String
  totalAmount BigInt
  totalUsers  Int
  createdAt   DateTime @default(now())
}

model RewardEpoch {
  id         String            @id @default(cuid())
  epochNo    Int               @unique
  merkleRoot String?
  startsAt   DateTime
  endsAt     DateTime
  createdAt  DateTime          @default(now())
  claims     RewardClaim[]
  leaves     RewardEpochLeaf[]
}

model RewardEpochLeaf {
  id        String      @id @default(cuid())
  epochId   String
  userId    String
  amount    BigInt
  leafIndex Int
  proofJson String
  epoch     RewardEpoch @relation(fields: [epochId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([epochId, userId])
  @@unique([epochId, leafIndex])
  @@index([userId])
}

model RewardClaim {
  id        String      @id @default(cuid())
  userId    String
  epochId   String
  amount    BigInt
  status    ClaimStatus @default(PROCESSING)
  leafIndex Int?
  txSig     String?     @unique
  startedAt DateTime    @default(now())
  claimedAt DateTime?
  error     String?
  epoch     RewardEpoch @relation(fields: [epochId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, epochId])
  @@index([userId, status])
}

enum UserRole {
  USER
  MOD
  ADMIN
}

enum SubscriptionTier {
  MEMBER
  DIAMOND
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELED
  PENDING
  PARTIAL
}

enum CommentStatus {
  ACTIVE
  REMOVED
}

enum RewardStatus {
  PENDING
  PAID
  VOID
  PROCESSING
}

enum RewardType {
  WEEKLY_LIKES
  WEEKLY_MVM
  WEEKLY_COMMENTS
  REF_L1
  REF_L2
  REF_L3
  WEEKLY_VOTER
  ALLTIME_LIKES
}

enum AdminActionKey {
  RECOMPUTE_VIDEO_RANKS
  RECOMPUTE_REWARDS_EPOCH
  RECALCULATE_LEADERBOARDS
  REBUILD_SEARCH_INDEX
  FLUSH_CLOUDFLARE_CACHE
  RECOMPUTE_ANALYTICS
}

enum ClaimStatus {
  PROCESSING
  CLAIMED
  FAILED
}

enum ManualPayMethod {
  CASHAPP
}

enum ManualPayStatus {
  PENDING
  APPROVED
  DENIED
  EXPIRED
}

// ========== On-Chain Claim System ==========

model ClaimEpoch {
  epoch        Int         @id
  weekKey      String      @unique // "2026-01-18" = Sunday midnight PT
  rootHex      String      @db.VarChar(64) // 32 bytes hex, lowercase
  totalAtomic  BigInt
  leafCount    Int
  createdAt    DateTime    @default(now())
  setOnChain   Boolean     @default(false)
  onChainTxSig String?

  leaves       ClaimLeaf[]
}

model ClaimLeaf {
  id           String     @id @default(cuid())
  epoch        Int
  weekKey      String
  userId       String
  wallet       String     @db.VarChar(64) // base58
  index        Int
  amountAtomic BigInt
  proofHex     Json       // array of 32-byte hex strings

  createdAt    DateTime   @default(now())

  epochRel     ClaimEpoch @relation(fields: [epoch], references: [epoch], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([epoch, wallet])
  @@unique([weekKey, wallet])
  @@index([weekKey, userId])
  @@index([wallet])
}

model ManualPayment {
  id               String           @id @default(cuid())
  userId           String
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  method           ManualPayMethod  @default(CASHAPP)
  status           ManualPayStatus  @default(PENDING)

  requestedTier    SubscriptionTier // MEMBER | DIAMOND
  planCode         String           // member_monthly | diamond_yearly etc
  amountUsd        Int              // cents
  currency         String           @default("USD")

  payerHandle      String?
  note             String?
  proofUrl         String?
  verifyCode       String           @unique

  provisionalUntil DateTime
  createdAt        DateTime         @default(now())
  reviewedAt       DateTime?
  reviewedBy       String?
  adminNote        String?

  @@index([status, createdAt])
  @@index([userId, createdAt])
}
