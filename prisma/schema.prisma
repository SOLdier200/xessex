datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================================================
// ENUMS
// ============================================================================

enum UserRole {
  USER
  MOD
  ADMIN
}

enum SubscriptionTier {
  MEMBER
  DIAMOND
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELED
  PENDING
}

enum CommentStatus {
  ACTIVE
  REMOVED
}

// ============================================================================
// USER & AUTH
// ============================================================================

model User {
  id            String   @id @default(cuid())
  walletAddress String?  @unique
  email         String?  @unique
  passHash      String?
  role          UserRole @default(USER)
  createdAt     DateTime @default(now())

  sessions         Session[]
  subscription     Subscription?
  commentsAuthored Comment[]            @relation("CommentAuthor")
  commentsRemoved  Comment[]            @relation("CommentRemovedBy")
  starRatings      VideoStarRating[]
  memberVotes      CommentMemberVote[]
  modVotes         CommentModVote[]
  scoreAdjustments VideoScoreAdjustment[]
  integrityFlagsMod    ModeratorIntegrityFlag[] @relation("FlaggedMod")
  integrityFlagsAuthor ModeratorIntegrityFlag[] @relation("FlaggedAuthor")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Subscription {
  id        String             @id @default(cuid())
  userId    String             @unique
  tier      SubscriptionTier
  status    SubscriptionStatus @default(PENDING)
  expiresAt DateTime?
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  // Provider tracking
  nowPaymentsPaymentId String?
  nowPaymentsInvoiceId String?
  nowPaymentsOrderId   String?  @unique // unique per checkout attempt for safe IPN correlation
  lastTxSig            String? // replay protection for SOL payments

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([expiresAt])
}

// ============================================================================
// VIDEO
// ============================================================================

model Video {
  id           String   @id @default(cuid())
  slug         String   @unique
  title        String
  embedUrl     String
  thumbnailUrl String?
  tags         String[] @default([])
  createdAt    DateTime @default(now())

  isShowcase Boolean @default(false) // exactly 3 should be true

  // Ranking inputs
  adminScore Int   @default(50) // 0..100 clamp in code
  viewsCount Int   @default(0)

  // Cached star aggregates
  avgStars   Float @default(0)
  starsCount Int   @default(0)

  comments    Comment[]
  starRatings VideoStarRating[]
  adjustments VideoScoreAdjustment[]

  @@index([isShowcase])
}

model VideoStarRating {
  id        String   @id @default(cuid())
  videoId   String
  userId    String
  stars     Int // 1-5
  createdAt DateTime @default(now())

  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([videoId, userId])
  @@index([userId])
}

// ============================================================================
// COMMENTS (Diamond-only, permanent, Source ID)
// ============================================================================

model Comment {
  id        String        @id @default(cuid()) // This is the SOURCE ID
  videoId   String
  authorId  String
  body      String
  createdAt DateTime      @default(now())
  status    CommentStatus @default(ACTIVE)

  // Cached vote counts (updated atomically on vote)
  memberLikes    Int @default(0)
  memberDislikes Int @default(0)

  // Removal tracking (only mods can remove)
  removedById   String?
  removedAt     DateTime?
  removedReason String?

  video     Video  @relation(fields: [videoId], references: [id], onDelete: Cascade)
  author    User   @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Restrict)
  removedBy User?  @relation("CommentRemovedBy", fields: [removedById], references: [id], onDelete: SetNull)

  memberVotes      CommentMemberVote[]
  modVotes         CommentModVote[]
  scoreAdjustments VideoScoreAdjustment[]

  @@index([videoId])
  @@index([authorId])
  @@index([status])
}

// ============================================================================
// COMMENT VOTES
// ============================================================================

// Member/Diamond thumbs up/down (public counts)
model CommentMemberVote {
  id            String   @id @default(cuid())
  commentId     String
  voterId       String
  value         Int      // +1 (like) or -1 (dislike)
  createdAt     DateTime @default(now())   // First vote time (for 60s window)
  flipCount     Int      @default(0)       // 0 or 1 (one flip allowed)
  lastChangedAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  voter   User    @relation(fields: [voterId], references: [id], onDelete: Cascade)

  @@unique([commentId, voterId])
  @@index([voterId])
}

// Admin/Mod hidden votes (not displayed publicly, used for scoring)
model CommentModVote {
  id            String   @id @default(cuid())
  commentId     String
  modId         String
  value         Int // +1 or -1
  flipCount     Int      @default(0) // max 5 flips allowed
  lastChangedAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod     User    @relation(fields: [modId], references: [id], onDelete: Cascade)

  @@unique([commentId, modId])
  @@index([modId])
}

// ============================================================================
// VIDEO SCORE ADJUSTMENT (Source ID workflow)
// ============================================================================

model VideoScoreAdjustment {
  id        String   @id @default(cuid())
  videoId   String
  commentId String // Source ID - must reference valid comment
  modId     String
  direction Int // +1 or -1
  createdAt DateTime @default(now())

  video   Video   @relation(fields: [videoId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod     User    @relation(fields: [modId], references: [id], onDelete: Cascade)

  @@index([videoId])
  @@index([commentId])
  @@index([modId])
}

// ============================================================================
// HONEST MODERATORS DETECTION
// ============================================================================

model ModeratorIntegrityFlag {
  id         String    @id @default(cuid())
  modId      String
  authorId   String
  reason     String
  createdAt  DateTime  @default(now())
  resolvedAt DateTime?

  mod    User @relation("FlaggedMod", fields: [modId], references: [id], onDelete: Cascade)
  author User @relation("FlaggedAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([modId])
  @@index([authorId])
}

// ============================================================================
// RATE LIMITING & LOGGING
// ============================================================================

model RateLimit {
  id          String @id @default(cuid())
  scope       String // 'vote:user' or 'vote:ip'
  key         String // userId or ip
  windowStart Int    // unix timestamp / window_size
  count       Int    @default(0)

  @@unique([scope, key, windowStart])
  @@index([scope, key, windowStart])
}

model VoteEvent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  userId    String?
  commentId String
  ip        String
  userAgent String?
  action    String // 'up', 'down', 'flip', 'noop', 'blocked'
  vote      Int? // +1/-1 when applicable
  prevVote  Int?

  @@index([ip, createdAt])
  @@index([userId, createdAt])
}
