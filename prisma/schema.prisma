generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  directUrl         = env("DIRECT_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                       String                   @id @default(cuid())
  memberId                 String                   @unique @default(cuid())
  walletAddress            String?                  @unique
  role                     UserRole                 @default(USER)
  createdAt                DateTime                 @default(now())
  email                    String?                  @unique
  passHash                 String?
  welcomeEmailSentAt       DateTime?
  supabaseId               String?                  @unique
  mvmPoints                Int                      @default(0)
  referralCode             String?                  @unique
  referredAt               DateTime?
  referredById             String?
  recoveryEmail            String?                  @unique
  recoveryEmailVerifiedAt  DateTime?
  allTimeStats         AllTimeUserStat[]
  commentsAuthored     Comment[]                @relation("CommentAuthor")
  commentsRemoved      Comment[]                @relation("CommentRemovedBy")
  commentReportsMade   CommentReport[]          @relation("CommentReportReporter")
  commentReportsResolved CommentReport[]        @relation("CommentReportResolver")
  memberVotes          CommentMemberVote[]
  modVotes             CommentModVote[]
  sourceGradesEarned   CommentSourceGrade[]     @relation("CommentSourceGradeAuthor")
  sourceGradesMade     CommentSourceGrade[]     @relation("CommentSourceGradeMod")
  integrityFlagsAuthor ModeratorIntegrityFlag[] @relation("FlaggedAuthor")
  integrityFlagsMod    ModeratorIntegrityFlag[] @relation("FlaggedMod")
  monthlyStats         MonthlyUserStat[]
  passwordResetTokens  PasswordResetToken[]
  rewardClaims         RewardClaim[]
  rewardEpochLeaves    RewardEpochLeaf[]
  rewardEvents         RewardEvent[]
  referralEarningsFrom RewardEvent[]         @relation("ReferralSource")
  claimLeaves          ClaimLeaf[]
  sessions             Session[]
  referredBy           User?                    @relation("UserReferrals", fields: [referredById], references: [id])
  referrals            User[]                   @relation("UserReferrals")
  scoreAdjustments     VideoScoreAdjustment[]
  starRatings          VideoStarRating[]
  walletLinkChallenges WalletLinkChallenge[]
  weeklyStats          WeeklyUserStat[]
  weeklyVoterStats     WeeklyVoterStat[]
  diamondTokens        DiamondToken[]

  // Rewards Drawing & Special Credits relations
  walletSnapshots      WalletBalanceSnapshot[]
  specialCreditAccount SpecialCreditAccount?
  specialCreditLedger  SpecialCreditLedger[]
  raffleTickets        RaffleTicket[]
  raffleWins           RaffleWinner[]
  claimSalts           ClaimSalt[]

  // Video unlock system
  videoUnlocks         VideoUnlock[]

  // Comment moderation
  commentBanStatus     CommentBanStatus     @default(ALLOWED)
  commentBanUntil      DateTime?            // For temporary bans
  commentBanReason     String?
  commentWarnings      CommentWarning[]
  commentBans          CommentBan[]

  // Vote moderation (likes/dislikes)
  voteBanStatus        CommentBanStatus     @default(ALLOWED)
  voteBanUntil         DateTime?
  voteBanReason        String?

  // Rating moderation (star ratings)
  ratingBanStatus      CommentBanStatus     @default(ALLOWED)
  ratingBanUntil       DateTime?
  ratingBanReason      String?

  // Mod action tracking
  modActionsReceived   ModAction[]          @relation("ModActionTarget")
  modActionsPerformed  ModAction[]          @relation("ModActionPerformer")

  // Messages system
  messagesReceived     UserMessage[]        @relation("MessageRecipient")
  messagesSent         UserMessage[]        @relation("MessageSender")
  starAbuseWarnings    StarAbuseWarning[]

  // User blocking
  blockedUsers         UserBlock[]          @relation("UserBlocker")
  blockedByUsers       UserBlock[]          @relation("UserBlocked")

  // Pool-aware rewards tracking
  dailyActive          UserDailyActive[]
  flatActionLedger     FlatActionLedger[]

  @@index([referredById])
  @@index([commentBanStatus])
  @@index([voteBanStatus])
  @@index([ratingBanStatus])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

enum WalletLinkPurpose {
  AUTH_LINK
}

model WalletLinkChallenge {
  id        String            @id @default(cuid())
  userId    String
  nonce     String            @unique
  message   String
  createdAt DateTime          @default(now())
  expiresAt DateTime
  usedAt    DateTime?
  purpose   WalletLinkPurpose @default(AUTH_LINK)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([purpose])
}

model PasswordResetToken {
  id            String    @id @default(cuid())
  userId        String
  tokenHash     String    @unique
  expiresAt     DateTime
  usedAt        DateTime?
  createdAt     DateTime  @default(now())
  resendEmailId String?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([resendEmailId])
}

model PasswordResetAttempt {
  id        String   @id @default(cuid())
  email     String
  ip        String
  userAgent String?
  action    String
  allowed   Boolean
  reason    String?
  createdAt DateTime @default(now())

  @@index([email, createdAt])
  @@index([ip, createdAt])
  @@index([action, createdAt])
}

model ResendWebhookEvent {
  id            String   @id @default(cuid())
  svixId        String   @unique
  svixTimestamp String?
  svixSignature String?
  type          String
  createdAt     DateTime @default(now())
  resendEmailId String?
  to            String?
  from          String?
  subject       String?
  payload       Json

  @@index([type, createdAt])
  @@index([resendEmailId])
  @@index([to])
}



model Video {
  id           String                 @id @default(cuid())
  slug         String                 @unique
  title        String
  embedUrl     String
  tags         String[]               @default([])
  createdAt    DateTime               @default(now())
  adminScore   Int                    @default(75)
  viewsCount   Int                    @default(0)
  avgStars     Float                  @default(0)
  starsCount   Int                    @default(0)
  thumbnailUrl String?
  sourceViews  Int                    @default(0)
  rank         Int?                   @unique

  // Video unlock system fields
  kind         VideoKind              @default(EMBED)
  isActive     Boolean                @default(true)
  sortOrder    Int                    @default(0)
  unlockCost   Int                    @default(0)  // 0=free, 100=embed, 1000=xessex
  mediaUrl     String?                             // For XESSEX-owned content
  posterUrl    String?

  comments     Comment[]
  sourceGrades CommentSourceGrade[]
  adjustments  VideoScoreAdjustment[]
  starRatings  VideoStarRating[]
  unlocks      VideoUnlock[]

  @@index([rank])
  @@index([kind, isActive, sortOrder])
}

model VideoStarRating {
  id        String   @id @default(cuid())
  videoId   String
  userId    String
  stars     Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([videoId, userId])
  @@index([userId])
}

model Comment {
  id               String                 @id @default(cuid())
  videoId          String
  authorId         String
  body             String
  bodyNormalized   String?
  createdAt        DateTime               @default(now())
  status           CommentStatus          @default(ACTIVE)
  autoReason       String?
  removedById      String?
  removedAt        DateTime?
  removedReason    String?
  memberDislikes   Int                    @default(0)
  memberLikes      Int                    @default(0)
  modLikes         Int                    @default(0)
  modDislikes      Int                    @default(0)
  score            Int                    @default(0)
  author           User                   @relation("CommentAuthor", fields: [authorId], references: [id])
  removedBy        User?                  @relation("CommentRemovedBy", fields: [removedById], references: [id])
  video            Video                  @relation(fields: [videoId], references: [id], onDelete: Cascade)
  memberVotes      CommentMemberVote[]
  modVotes         CommentModVote[]
  sourceGrades     CommentSourceGrade[]
  scoreAdjustments VideoScoreAdjustment[]
  reports          CommentReport[]

  @@index([videoId])
  @@index([authorId])
  @@index([status])
}

model CommentMemberVote {
  id            String   @id @default(cuid())
  commentId     String
  voterId       String
  value         Int
  flipCount     Int      @default(0)
  lastChangedAt DateTime @default(now())
  createdAt     DateTime @default(now())
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  voter         User     @relation(fields: [voterId], references: [id], onDelete: Cascade)

  @@unique([commentId, voterId])
  @@index([voterId])
}

model CommentModVote {
  id            String   @id @default(cuid())
  commentId     String
  modId         String
  value         Int
  flipCount     Int      @default(0)
  lastChangedAt DateTime @default(now())
  createdAt     DateTime @default(now())
  comment       Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod           User     @relation(fields: [modId], references: [id], onDelete: Cascade)

  @@unique([commentId, modId])
  @@index([modId])
}

model CommentReport {
  id           String              @id @default(cuid())
  commentId    String
  reporterId   String
  reason       CommentReportReason
  note         String?
  createdAt    DateTime            @default(now())
  resolvedAt   DateTime?
  resolvedById String?

  comment     Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  reporter    User    @relation("CommentReportReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  resolvedBy  User?   @relation("CommentReportResolver", fields: [resolvedById], references: [id])

  @@unique([commentId, reporterId])
  @@index([commentId, createdAt])
  @@index([reporterId, createdAt])
  @@index([resolvedAt])
}

model VideoScoreAdjustment {
  id        String   @id @default(cuid())
  videoId   String
  commentId String
  modId     String
  direction Int
  createdAt DateTime @default(now())
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod       User     @relation(fields: [modId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@index([videoId])
  @@index([commentId])
  @@index([modId])
}

model ModeratorIntegrityFlag {
  id         String    @id @default(cuid())
  modId      String
  authorId   String
  reason     String
  createdAt  DateTime  @default(now())
  resolvedAt DateTime?
  author     User      @relation("FlaggedAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  mod        User      @relation("FlaggedMod", fields: [modId], references: [id], onDelete: Cascade)

  @@index([modId])
  @@index([authorId])
}

model RateLimit {
  id          String @id @default(cuid())
  scope       String
  key         String
  windowStart Int
  count       Int    @default(0)

  @@unique([scope, key, windowStart])
  @@index([scope, key, windowStart])
}

model VoteEvent {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  userId    String?
  commentId String
  ip        String
  userAgent String?
  action    String
  vote      Int?
  prevVote  Int?

  @@index([ip, createdAt])
  @@index([userId, createdAt])
}

model CommentSourceGrade {
  id        String   @id @default(cuid())
  commentId String
  videoId   String
  modId     String
  authorId  String
  direction Int
  createdAt DateTime @default(now())
  author    User     @relation("CommentSourceGradeAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  mod       User     @relation("CommentSourceGradeMod", fields: [modId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([commentId, modId])
  @@index([authorId, createdAt])
  @@index([videoId, createdAt])
  @@index([modId, createdAt])
}

model SiteStat {
  key       String   @id
  value     BigInt   @default(0)
  updatedAt DateTime @updatedAt
}

model RewardEvent {
  id          String       @id @default(cuid())
  userId      String
  referralFromUserId String?
  type        RewardType
  amount      BigInt
  status      RewardStatus @default(PENDING)
  weekKey     String
  refType     String
  refId       String
  txSig       String?
  createdAt   DateTime     @default(now())
  paidAt      DateTime?
  claimedAt   DateTime?
  merkleIndex Int?
  merkleProof String?
  user        User         @relation(fields: [userId], references: [id])
  referralFromUser User?   @relation("ReferralSource", fields: [referralFromUserId], references: [id], onDelete: SetNull)

  @@unique([refType, refId])
  @@index([weekKey, status])
  @@index([userId, status])
  @@index([referralFromUserId])
  @@index([type, status])
}

model WeeklyUserStat {
  id              String   @id @default(cuid())
  weekKey         String
  userId          String
  pool            StatPool @default(EMBED)
  diamondComments Int      @default(0)
  mvmPoints       Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  scoreReceived   Int      @default(0)
  pendingAtomic   BigInt   @default(0) // Accumulated pending XESS for this week (9 decimals)
  paidAtomic      BigInt   @default(0) // Finalized/paid XESS for this week (9 decimals)
  user            User     @relation(fields: [userId], references: [id])

  @@unique([weekKey, userId, pool])
  @@index([weekKey, pool])
  @@index([userId, pool])
}

// Reward distribution mode
enum RewardMode {
  FLAT_ONLY          // Only flat-rate rewards, no leaderboard
  LEADERBOARD_ONLY   // Only leaderboard rewards, no flat
  FLAT_THEN_LEADERBOARD // Flat first (capped), remainder to leaderboards
}

model AdminConfig {
  id                       String     @id @default(cuid())
  minWeeklyScoreThreshold  Int        @default(10)
  minMvmThreshold          Int        @default(1)
  allTimeLikesBpsOfLikes   Int        @default(1000)
  memberVoterBpsOfLikes    Int        @default(500)
  voterRewardPerVoteAtomic BigInt     @default(0)

  // Pool budget splits (basis points, must sum to 10000)
  xessexPoolBps            Int        @default(6900)  // 69%
  embedPoolBps             Int        @default(3100)  // 31%

  // Flat-rate caps per user per pool (6-decimal XESS)
  flatCapXessexAtomic      BigInt     @default(5000000000)  // 5,000 XESS
  flatCapEmbedAtomic       BigInt     @default(2000000000)  // 2,000 XESS

  // Weekly active bonus (6-decimal XESS) for users active all 7 days
  weeklyActiveBonusAtomic  BigInt     @default(100000000)   // 100 XESS

  // Optional emission override (null = use schedule)
  weeklyEmissionOverride   BigInt?

  // Whether flat payouts can scale down if over budget
  allowFlatScaling         Boolean    @default(true)

  // Reward distribution mode
  rewardMode               RewardMode @default(FLAT_THEN_LEADERBOARD)

  updatedAt                DateTime   @updatedAt
  createdAt                DateTime   @default(now())
}

model AdminActionRun {
  id        String         @id @default(cuid())
  key       AdminActionKey @unique
  lastRunAt DateTime?
  lastOk    Boolean        @default(false)
  lastMsg   String?
  updatedAt DateTime       @updatedAt
}

model AllTimeUserStat {
  id            String   @id @default(cuid())
  userId        String
  pool          StatPool @default(EMBED)
  scoreReceived Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])

  @@unique([userId, pool])
  @@index([pool])
  @@index([userId, pool])
}

model MonthlyUserStat {
  id        String   @id @default(cuid())
  monthKey  String
  userId    String
  pool      StatPool @default(EMBED)
  mvmPoints Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@unique([monthKey, userId, pool])
  @@index([monthKey, pool])
  @@index([userId, pool])
}

model WeeklyVoterStat {
  id        String   @id @default(cuid())
  weekKey   String
  userId    String
  pool      StatPool @default(EMBED)
  votesCast Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@unique([weekKey, userId, pool])
  @@index([weekKey, pool])
  @@index([userId, pool])
}

model RewardBatch {
  id          String      @id @default(cuid())
  weekKey     String      @unique
  status      BatchStatus @default(RUNNING)
  runId       String?     // For observability/tracing
  merkleRoot  String?     // Null until complete
  totalAmount BigInt?     // Null until complete
  totalUsers  Int?        // Null until complete
  startedAt   DateTime    @default(now())
  finishedAt  DateTime?
  createdAt   DateTime    @default(now())
}

// Track burned tokens (unused emissions, manual burns, etc.)
model BurnRecord {
  id          String   @id @default(cuid())
  weekKey     String?  // Null for manual burns
  pool        StatPool // XESSEX or EMBED
  reason      String   // "unused_emission", "manual", etc.
  amount      BigInt   // Amount in 6 decimals
  description String?  // Optional human-readable description
  txSig       String?  // Optional on-chain burn tx signature
  createdAt   DateTime @default(now())

  @@index([weekKey])
  @@index([pool])
  @@index([createdAt])
}

model RewardEpoch {
  id         String            @id @default(cuid())
  epochNo    Int               @unique
  merkleRoot String?
  startsAt   DateTime
  endsAt     DateTime
  createdAt  DateTime          @default(now())
  claims     RewardClaim[]
  leaves     RewardEpochLeaf[]
}

model RewardEpochLeaf {
  id        String      @id @default(cuid())
  epochId   String
  userId    String
  amount    BigInt
  leafIndex Int
  proofJson String
  epoch     RewardEpoch @relation(fields: [epochId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([epochId, userId])
  @@unique([epochId, leafIndex])
  @@index([userId])
}

model RewardClaim {
  id        String      @id @default(cuid())
  userId    String
  epochId   String
  amount    BigInt
  status    ClaimStatus @default(PROCESSING)
  leafIndex Int?
  txSig     String?     @unique
  startedAt DateTime    @default(now())
  claimedAt DateTime?
  error     String?
  epoch     RewardEpoch @relation(fields: [epochId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, epochId])
  @@index([userId, status])
}

enum UserRole {
  USER
  MOD
  ADMIN
}

enum CommentBanStatus {
  ALLOWED           // Can comment freely
  WARNED            // Has received warnings
  TEMP_BANNED       // Temporarily banned
  PERM_BANNED       // Permanently banned
  UNBANNED          // Was banned, now unbanned (shown greyed out in mod panel)
}

// Tracks warnings issued to users for removed comments
model CommentWarning {
  id             String   @id @default(cuid())
  userId         String
  warningType    String   // "spam_warning_3", "suspension_warning_5", "permanent_ban_10"
  removedCount   Int      // Number of removed comments at time of warning
  message        String   // Warning message shown to user
  acknowledgedAt DateTime?
  createdAt      DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

// Tracks ban history for users
model CommentBan {
  id          String    @id @default(cuid())
  userId      String
  banType     String    // "temp_1_week", "permanent"
  reason      String
  bannedAt    DateTime  @default(now())
  expiresAt   DateTime? // null for permanent bans
  unbannedAt  DateTime?
  unbannedBy  String?   // mod/admin who unbanned
  rebannedAt  DateTime? // if user was rebanned after unban
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([banType])
}

// Tracks all moderator actions for admin review
model ModAction {
  id            String   @id @default(cuid())
  modId         String   // Moderator who performed the action
  targetUserId  String   // User affected by the action
  actionType    String   // e.g., "COMMENT_BAN", "COMMENT_UNBAN", "VOTE_BAN", "RATING_BAN", etc.
  actionSubtype String?  // e.g., "temp_1_week", "temp_2_week", "temp_4_week", "permanent"
  reason        String?  // Reason for the action
  details       String?  // Additional details (JSON string if needed)
  createdAt     DateTime @default(now())

  mod           User     @relation("ModActionPerformer", fields: [modId], references: [id], onDelete: Cascade)
  targetUser    User     @relation("ModActionTarget", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([modId])
  @@index([targetUserId])
  @@index([actionType])
  @@index([createdAt])
}

// User messages system (warnings, admin/mod messages)
model UserMessage {
  id          String    @id @default(cuid())
  userId      String    // Recipient
  senderId    String?   // Sender (null for system messages)
  type        String    // "WARNING", "DIRECT", "MASS", "SYSTEM"
  subject     String
  body        String
  readAt      DateTime?
  createdAt   DateTime  @default(now())

  user        User      @relation("MessageRecipient", fields: [userId], references: [id], onDelete: Cascade)
  sender      User?     @relation("MessageSender", fields: [senderId], references: [id], onDelete: SetNull)

  @@index([userId, readAt])
  @@index([senderId])
  @@index([type])
  @@index([createdAt])
}

// Track star rating abuse warnings sent to users
model StarAbuseWarning {
  id              String   @id @default(cuid())
  userId          String
  oneStarCount    Int      // Count of 1-star ratings at time of warning
  createdAt       DateTime @default(now())
  acknowledgedAt  DateTime?

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// User blocking for messaging
model UserBlock {
  id          String   @id @default(cuid())
  blockerId   String   // User who is blocking
  blockedId   String   // User who is blocked
  createdAt   DateTime @default(now())

  blocker     User     @relation("UserBlocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked     User     @relation("UserBlocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

enum CommentStatus {
  ACTIVE
  PENDING
  HIDDEN
  REMOVED
}

enum CommentReportReason {
  SPAM
  HARASSMENT
  HATE
  THREAT
  SEXUAL_VIOLENCE
  OTHER
}

enum RewardStatus {
  PENDING
  PAID
  VOID
  PROCESSING
}

enum RewardType {
  WEEKLY_LIKES
  WEEKLY_MVM
  WEEKLY_COMMENTS
  REF_L1
  REF_L2
  REF_L3
  WEEKLY_VOTER
  ALLTIME_LIKES
}

enum BatchStatus {
  RUNNING
  DONE
  FAILED
}

enum AdminActionKey {
  RECOMPUTE_VIDEO_RANKS
  RECOMPUTE_REWARDS_EPOCH
  RECALCULATE_LEADERBOARDS
  REBUILD_SEARCH_INDEX
  FLUSH_CLOUDFLARE_CACHE
  RECOMPUTE_ANALYTICS
  BUILD_CLAIM_EPOCH
  BUILD_CLAIM_EPOCH_V2
}

enum ClaimStatus {
  PROCESSING
  CLAIMED
  FAILED
}

// Video content type for unlock system
enum VideoKind {
  EMBED  // External embed (PornHub, XVideos, etc.)
  XESSEX // Xessex-owned content
}

// Pool enum for stat tables (rewards split by content type)
enum StatPool {
  EMBED   // Stats from EMBED video interactions
  XESSEX  // Stats from XESSEX video interactions
}

// Flat-rate action types for reward tracking
enum FlatActionType {
  RATING
  COMMENT
  LIKE_RECEIVED
  COMMENT_SOURCED
  DAILY_ACTIVE
}

// Track daily activity per user per pool (for weekly active bonus)
model UserDailyActive {
  id        String   @id @default(cuid())
  userId    String
  day       DateTime // Start-of-day UTC
  pool      StatPool
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, day, pool], name: "userId_day_pool")
  @@index([day])
  @@index([userId])
  @@index([pool])
}

// Flat-rate action ledger for deterministic weekly payouts
model FlatActionLedger {
  id        String         @id @default(cuid())
  weekKey   String
  userId    String
  pool      StatPool
  action    FlatActionType
  units     Int            @default(1)
  amount    BigInt         // 6-decimal XESS (same as RewardEvent.amount)
  refId     String         @unique
  createdAt DateTime       @default(now())

  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([weekKey, pool])
  @@index([userId, weekKey])
  @@index([pool, action])
}


enum DiamondTokenKind {
  VERIFY_EMAIL
  RESTORE
}

model DiamondToken {
  id        String           @id @default(cuid())
  userId    String
  kind      DiamondTokenKind
  tokenHash String           @unique
  usedAt    DateTime?
  expiresAt DateTime
  createdAt DateTime         @default(now())

  requestIp String?
  requestUa String?

  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, kind])
  @@index([expiresAt])
}


// ========== Rewards Drawing & Special Credits Enums ==========

enum RaffleType {
  CREDITS // Special Credits drawing only
  XESS    // Legacy - kept for database compatibility
}

enum RaffleStatus {
  OPEN
  CLOSED
  DRAWN
}

enum WinnerStatus {
  PENDING
  CLAIMED
  EXPIRED
}


// ========== On-Chain Claim System ==========

model ClaimEpoch {
  epoch        Int         @id
  weekKey      String      // "2026-01-18" = Sunday midnight PT
  rootHex      String      @db.VarChar(64) // 32 bytes hex, lowercase
  totalAtomic  BigInt
  leafCount    Int
  createdAt    DateTime    @default(now())
  setOnChain   Boolean     @default(false)
  onChainTxSig String?
  setOnChainAt DateTime?
  version      Int         @default(1) // 1 = wallet-based (no salt), 2 = wallet-based (with salt)
  buildHash    String?     // SHA256 of inputs for idempotency

  leaves       ClaimLeaf[]

  @@unique([weekKey, version])
}

model ClaimLeaf {
  id           String     @id @default(cuid())
  epoch        Int
  weekKey      String
  userId       String
  wallet       String?    @db.VarChar(64) // base58 - nullable for v2 epochs
  index        Int
  amountAtomic BigInt
  proofHex     Json       // array of 32-byte hex strings
  userKeyHex   String?    @db.VarChar(64) // 32 bytes hex - v2 only
  claimSaltHex String?    @db.VarChar(64) // 32 bytes hex - v2 only

  createdAt    DateTime   @default(now())

  epochRel     ClaimEpoch @relation(fields: [epoch], references: [epoch], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([epoch, wallet])
  @@unique([epoch, userKeyHex])
  @@unique([epoch, userId])
  @@index([weekKey, userId])
  @@index([wallet])
}


// ========== Raffle & Special Credits Models ==========

model WalletBalanceSnapshot {
  id            String   @id @default(cuid())
  wallet        String   @db.VarChar(64) // base58 Solana wallet
  dateKey       String   // "2026-01-26" PT date
  weekKey       String   // "2026-01-26" ending Sunday PT
  balanceAtomic BigInt   // XESS balance (9 decimals)
  tier          Int      // Tier index (0 = no tier, 1-7 = tiers)
  createdAt     DateTime @default(now())

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([wallet, dateKey])
  @@index([weekKey])
  @@index([userId])
}

model SpecialCreditAccount {
  id           String   @id @default(cuid())
  userId       String   @unique
  balanceMicro BigInt   @default(0) // 1 credit = 1000 microcredits
  carryMicro   BigInt   @default(0) // Fractional carry from daily accrual
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SpecialCreditLedger {
  id          String   @id @default(cuid())
  userId      String
  weekKey     String   // Week this credit change relates to
  amountMicro BigInt   // Positive = credit, Negative = debit
  reason      String   // Human-readable reason
  refType     String   // "DAILY_ACCRUAL", "RAFFLE_BUY_CREDITS", "RAFFLE_PRIZE_CREDITS", etc.
  refId       String   // Unique ref for idempotency
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([refType, refId])
  @@index([userId, createdAt])
  @@index([weekKey])
}

// Rewards Drawing (Special Credits only - no XESS, no cash value)
model Raffle {
  id                       String       @id @default(cuid())
  weekKey                  String       // "2026-01-26" ending Sunday PT
  type                     RaffleType   // CREDITS only
  status                   RaffleStatus @default(OPEN)

  // Entry cost (Special Credits)
  ticketPriceCreditsMicro  BigInt?      // Cost per entry in microcredits

  // Prize pools (Special Credits only)
  userPoolCreditsMicro     BigInt       @default(0)  // User entries pool
  matchPoolCreditsMicro    BigInt       @default(0)  // System match pool
  rolloverCreditsMicro     BigInt       @default(0)  // Unclaimed prizes rollover

  totalTickets             BigInt       @default(0)

  opensAt                  DateTime
  closesAt                 DateTime
  drawnAt                  DateTime?

  createdAt                DateTime     @default(now())
  updatedAt                DateTime     @updatedAt

  tickets                  RaffleTicket[]
  winners                  RaffleWinner[]

  @@unique([weekKey, type])
  @@index([status, closesAt])
}

model RaffleTicket {
  id        String   @id @default(cuid())
  raffleId  String
  userId    String
  quantity  BigInt   @default(1)
  createdAt DateTime @default(now())

  raffle    Raffle   @relation(fields: [raffleId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([raffleId, userId])
  @@index([userId, createdAt])
}

// Drawing winner (Special Credits prize only)
model RaffleWinner {
  id                String       @id @default(cuid())
  raffleId          String
  userId            String
  place             Int          // 1, 2, or 3
  prizeCreditsMicro BigInt       @default(0) // Special Credits prize (no cash value)
  status            WinnerStatus @default(PENDING)
  expiresAt         DateTime     // Deadline to claim
  claimedAt         DateTime?
  createdAt         DateTime     @default(now())

  raffle            Raffle       @relation(fields: [raffleId], references: [id], onDelete: Cascade)
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([raffleId, place])
  @@index([userId, status])
  @@index([status, expiresAt])
}

// System match budget for rewards drawing (promotional, not user-funded)
model RaffleMatchBudget {
  id                   String   @id @default(cuid())
  weekKey              String   @unique // Week ending Sunday date
  creditsMatchCapMicro BigInt   @default(0) // Max credits to match this week
  creditsMatchedMicro  BigInt   @default(0) // Credits already matched
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// ========== V2 Claim System - Per-epoch salts for wallet-based claims ==========

model ClaimSalt {
  id           String   @id @default(cuid())
  epoch        Int
  userId       String
  userKeyHex   String   @db.VarChar(64) // 32 bytes hex - wallet pubkey bytes
  claimSaltHex String   @db.VarChar(64) // 32 bytes hex - random per (epoch, user)
  createdAt    DateTime @default(now())

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([epoch, userId])
  @@index([userId])
}

// ========== Video Unlock System ==========

model VideoUnlock {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String
  videoId   String
  cost      Int      // Credits spent at time of unlock (audit trail)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([userId, videoId])
  @@index([userId])
  @@index([videoId])
}

// ========== iOS Wallet Auth - Nonce for signature challenges ==========

model WalletNonce {
  id        String   @id @default(cuid())
  wallet    String   @unique // base58 wallet address
  nonce     String   // random challenge
  expiresAt DateTime
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@index([expiresAt])
}

// ========== Unlock Analytics ==========

model UnlockAnalyticsEvent {
  id        String   @id @default(cuid())
  userId    String?
  sessionId String?
  videoId   String?
  event     String   // e.g. LOCKED_IMPRESSION, UNLOCK_CLICK, UNLOCK_SUCCESS, etc.
  meta      Json?
  createdAt DateTime @default(now())

  @@index([createdAt])
  @@index([event, createdAt])
  @@index([userId, createdAt])
  @@index([videoId, createdAt])
}

// ========== Token Sale System ==========

model SaleConfig {
  id                    String    @id @default(cuid())
  activePhase           String    @default("private") // "private" | "public" | "closed"
  totalSupplyXess       BigInt    @default(1000000000)
  saleAllocationXess    BigInt    @default(350000000)
  privateAllocation     BigInt    @default(35000000)
  publicAllocation      BigInt    @default(315000000)
  walletCapXess         BigInt    @default(5000000)

  // Pricing in USD micros (e.g. 2500 = $0.002500)
  privatePriceUsdMicros BigInt @default(2500)
  publicPriceUsdMicros  BigInt @default(3000)

  // SOL pricing (lamports per XESS)
  privateLamportsPerXess BigInt @default(500)
  publicLamportsPerXess  BigInt @default(650)

  // Whitelist for private sale (Merkle root hex)
  privateMerkleRootHex  String?

  // Optional time gates
  privateStartsAt       DateTime?
  privateEndsAt         DateTime?
  publicStartsAt        DateTime?
  publicEndsAt          DateTime?

  // Accounting
  soldPrivateXess       BigInt    @default(0)
  soldPublicXess        BigInt    @default(0)

  updatedAt             DateTime  @updatedAt
  createdAt             DateTime  @default(now())
}

model SaleContribution {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  phase          String   // "private" | "public"
  wallet         String   // lowercased base58 string
  asset          String   // "SOL" | "USDC"

  // How much the buyer is purchasing
  xessAmount     BigInt   // amount of XESS allocated to this wallet

  // What they paid
  paidLamports   BigInt?  // SOL in lamports
  paidUsdcAtomic BigInt?  // USDC in atomic (6 decimals)

  // On-chain verification
  txSig          String?  @unique

  // Status
  status         String   @default("PENDING") // "PENDING" | "CONFIRMED" | "FAILED"
  confirmedAt    DateTime?

  @@index([wallet])
  @@index([phase])
  @@index([status])
}
